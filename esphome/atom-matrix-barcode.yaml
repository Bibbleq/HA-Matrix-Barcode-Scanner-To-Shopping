esphome:
  name: atom-matrix-barcode
  friendly_name: Atom Matrix Barcode

  # We set the scanner to CRLF suffix + trigger mode on boot, drain any echoes,
  # and force the control lines to a known idle state.
  on_boot:
    priority: -100
    then:
      # Tell the scanner to append CRLF (\r\n) to each decoded result
      - uart.write: [0x21, 0x51, 0xC2, 0x00, 0x02, 0x0D, 0x0A]
      # Use Key/Trigger (on-demand) scanning: cuts idle power/heat
      - uart.write: [0x21, 0x61, 0x41, 0x00]
      # Enable scanner auto-sleep to save power when idle
      - uart.write: [0x21, 0x61, 0x44, 0x01]   # Enable sleep
      - uart.write: [0x21, 0x61, 0x45, 0x23]   # Sleep timeout = 35s

      # Drain any echoed bytes so they don't get mis-parsed as a fake scan
      - delay: 200ms
      - lambda: |-
          while (id(scanner_uart).available()) {
            uint8_t ch; id(scanner_uart).read_byte(&ch);
          }
      # Force known idle state on control lines
      - switch.turn_off: scanner_trigger
      - switch.turn_off: scanner_aim
      # Initialize activity timer for deep sleep
      - lambda: 'id(last_activity_ms) = millis();'
      # Start connection status monitoring
      - script.execute: show_connecting_status

# ---------- One-place knobs for behavior (edit here to tune) ----------
# We expand these everywhere below (including inside lambdas).
substitutions:
  cooldown_ms: "2000"         # Global scan cooldown (ALL scans): 2s
  rearm_success_ms: "1200"    # After accepted scan, wait before re-arming
  rearm_block_ms: "1500"      # After blocked/duplicate, wait a bit longer
  session_timeout_ms: "30000" # End session if no accepted scan for 30s
  ready_timeout_ms: "30000"   # Show green "ready" status for 30s after HA connection
  deep_sleep_timeout_ms: "60000" # Enter deep sleep after 60s of inactivity

esp32:
  board: m5stack-atom
  framework:
    type: arduino

# ---------- Deep Sleep Configuration ----------
# Enables deep sleep mode to reduce idle power from ~0.8W to ~0.05W
# Device wakes on button press via hardware (GPIO39 button causes reset on Atom Matrix)
# OR on scheduled wake interval to check for wake conditions
deep_sleep:
  id: deep_sleep_control
  wakeup_pin:
    number: GPIO39
    inverted: true
    mode:
      input: true
    allow_other_uses: true  # Allow binary_sensor to also use this pin

logger:
  level: INFO                 # Use DEBUG temporarily if you need to inspect logs
  baud_rate: 0                # Disable UART0 logging (keeps pins free)

api:

ota:
  - platform: esphome
    password: !secret esphome_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# ---------- ATOM Matrix 5x5 LEDs ----------
# ESP32 RMT LED Strip driver works with both Arduino and ESP-IDF frameworks.
# Per M5's guidance, keep short flashes at ~20% to protect the acrylic diffuser/LEDs.
light:
  - platform: esp32_rmt_led_strip
    id: matrix_leds
    name: "Matrix LEDs"
    chipset: WS2812
    pin: GPIO27
    num_leds: 25
    rgb_order: GRB
    restore_mode: ALWAYS_OFF
    default_transition_length: 0s  # instant on/off for crisp feedback

# ---------- QR Base control pins (ACTIVE-LOW) — internal (hidden) ----------
# These are "raw" hardware lines to the scanner. We keep them internal to avoid UI clutter.
switch:
  - platform: gpio
    id: scanner_trigger
    internal: true
    pin:
      number: GPIO23
      inverted: true       # ON = pull low (active) = start decode
    restore_mode: ALWAYS_OFF

  - platform: gpio
    id: scanner_aim
    internal: true
    pin:
      number: GPIO33
      inverted: true       # ON = pull low (active) = allow aimer LED
    restore_mode: ALWAYS_OFF

# ---------- Physical ATOM button → start session (hidden) ----------
# GPIO39 is input-only; ATOM Matrix has a HW pull-up already.
# Marked internal so it doesn't show in HA, but it still triggers the script.
binary_sensor:
  - platform: gpio
    id: atom_button
    internal: true           # hide from HA UI; still runs automations
    pin:
      number: GPIO39
      inverted: true         # press pulls the line low on ATOM Matrix
      mode:
        input: true          # no internal pullup available on GPIO39
      allow_other_uses: true  # Allow deep_sleep to also use this pin as wakeup
    filters:
      - delayed_on: 20ms     # simple debounce
      - delayed_off: 20ms
    on_press:
      - lambda: 'id(last_activity_ms) = millis();'  # Reset deep sleep timer
      - script.stop: show_ready_status        # Stop ready status if showing
      - script.stop: ready_timeout_watchdog   # Stop ready watchdog
      - script.execute: start_scan_session

# ---------- UART to scanner ----------
uart:
  id: scanner_uart
  rx_pin: GPIO22          # module TX -> ESP RX (confirmed)
  tx_pin: GPIO19          # ESP TX  -> module RX (needed for config writes)
  baud_rate: 115200
  rx_buffer_size: 2048

# ---------- State, cooldown, and session control ----------
globals:
  - id: last_code
    type: std::string
    initial_value: "\"\""
  - id: last_time_ms
    type: uint32_t
    initial_value: "0"
  - id: last_accept_ms            # ONLY for cooldown gating (not session timing)
    type: uint32_t
    initial_value: "0"
  - id: session_last_ms           # Session timer: extends on accepted scans
    type: uint32_t
    initial_value: "0"
  - id: session_active            # True while we keep trigger/aim on
    type: bool
    initial_value: "false"
  - id: ready_status_shown        # True while showing green "ready" status
    type: bool
    initial_value: "false"
  - id: last_activity_ms          # Track last activity for deep sleep timer
    type: uint32_t
    initial_value: "0"

# ---------- Publish last code (fires HA event + green flash + re-arm during session) ----------
text_sensor:
  - platform: template
    id: scanned_code
    name: "Scanned Code"
    update_interval: never
    on_value:
      then:
        # Reset deep sleep timer on successful scan
        - lambda: 'id(last_activity_ms) = millis();'
        # Send an event into Home Assistant with the raw code text
        - homeassistant.event:
            event: esphome.barcode_scanned
            data:
              code: !lambda 'return x;'
        # Visual feedback (short & gentle to protect matrix)
        - script.execute: flash_green
        # Immediately re-arm the engine only if a session is active
        - if:
            condition:
              lambda: 'return id(session_active);'
            then:
              - script.execute: rearm_after_read

# ---------- Hybrid parser: CR/LF OR idle-timeout + printable ASCII filter + cooldown ----------
# Why hybrid? Some firmwares ignore CR/LF settings; idle fallback makes parsing robust.
# We sanitize to printable ASCII before publishing to avoid HA protobuf decode errors.
interval:
  - interval: 40ms
    then:
      - lambda: |-
          static std::string buf;
          static uint32_t last_rx_ms = 0;
          bool saw_line_end = false;

          // Drain bytes, track the time of the last received byte
          while (id(scanner_uart).available()) {
            uint8_t ch; if (!id(scanner_uart).read_byte(&ch)) break;
            char c = (char) ch;
            last_rx_ms = millis();
            if (c == '\r' || c == '\n') {
              saw_line_end = true;
            } else {
              buf.push_back(c);
            }
          }

          const uint32_t now = millis();
          const bool idle_flush = (!buf.empty() && (now - last_rx_ms >= 80));  // ~80ms quiet window

          if (saw_line_end || idle_flush) {
            // Trim outer spaces
            while (!buf.empty() && buf.front()==' ') buf.erase(0,1);
            while (!buf.empty() && buf.back()==' ')  buf.pop_back();

            // Keep printable ASCII only (0x20..0x7E) to protect HA protobuf
            std::string clean; clean.reserve(buf.size());
            for (char cc : buf) {
              unsigned char u = (unsigned char) cc;
              if (u >= 0x20 && u <= 0x7E) clean.push_back(cc);
            }

            if (!clean.empty()) {
              const uint32_t COOLDOWN_MS = ${cooldown_ms};  // <— 2s cooldown from substitutions
              const bool cooldown_ok = (now - id(last_accept_ms) > COOLDOWN_MS);
              // "newish" helps avoid accidental quick repeats if you later lower cooldown
              const bool is_newish   = (clean != id(last_code)) || (now - id(last_time_ms) > 2000);

              // Only publish during an active session; extend session on success
              if (id(session_active) && cooldown_ok && is_newish) {
                id(last_code)       = clean;
                id(last_time_ms)    = now;
                id(last_accept_ms)  = now;     // cooldown clock
                id(session_last_ms) = now;     // extend session timer
                id(scanned_code).publish_state(clean);
              } else if (id(session_active)) {
                // Duplicate or within cooldown: show red (gently) and re-arm for another try
                id(flash_red).execute();
                id(rearm_after_block).execute();
              }
            }
            buf.clear();
          }
  
  # Monitor API connection status and restart connecting status if disconnected
  - interval: 2s
    then:
      - if:
          condition:
            lambda: 'return !api::global_api_server->is_connected();'
          then:
            - if:
                condition:
                  lambda: 'return id(ready_status_shown) && !id(session_active);'
                then:
                  - script.execute: show_connecting_status

  # Monitor inactivity and enter deep sleep after timeout
  - interval: 5s
    then:
      - if:
          condition:
            lambda: |-
              const uint32_t DEEP_SLEEP_TIMEOUT_MS = ${deep_sleep_timeout_ms};
              const uint32_t now = millis();
              const bool is_idle = !id(session_active) && !id(ready_status_shown);
              
              // Rollover-safe time difference calculation
              uint32_t elapsed_ms;
              if (now >= id(last_activity_ms)) {
                elapsed_ms = now - id(last_activity_ms);
              } else {
                // Handle millis() rollover (occurs every ~49.7 days)
                elapsed_ms = (UINT32_MAX - id(last_activity_ms)) + now + 1;
              }
              
              const bool timeout_reached = (elapsed_ms >= DEEP_SLEEP_TIMEOUT_MS);
              
              if (is_idle && timeout_reached) {
                ESP_LOGI("deep_sleep", "Entering deep sleep after %u ms of inactivity", elapsed_ms);
                return true;
              }
              return false;
          then:
            - deep_sleep.enter: deep_sleep_control

# ---------- LED feedback + session scripts ----------
script:
  # Blink red/yellow while waiting for Home Assistant connection
  - id: show_connecting_status
    mode: restart
    then:
      - lambda: 'id(ready_status_shown) = false;'
      - lambda: 'id(last_activity_ms) = millis();'  # Reset deep sleep timer
      - while:
          condition:
            lambda: 'return !api::global_api_server->is_connected();'
          then:
            # Red blink
            - light.turn_on:
                id: matrix_leds
                brightness: 50%
                red: 1.0
                green: 0.0
                blue: 0.0
            - delay: 500ms
            - light.turn_off: matrix_leds
            - delay: 200ms
            # Yellow blink
            - light.turn_on:
                id: matrix_leds
                brightness: 50%
                red: 1.0
                green: 1.0
                blue: 0.0
            - delay: 500ms
            - light.turn_off: matrix_leds
            - delay: 200ms
      # When API connects, show ready status
      - script.execute: show_ready_status

  # Show solid green when connected and ready (with timeout)
  - id: show_ready_status
    mode: restart
    then:
      - lambda: 'id(ready_status_shown) = true;'
      - script.stop: show_connecting_status
      - light.turn_on:
          id: matrix_leds
          brightness: 70%
          red: 0.0
          green: 1.0
          blue: 0.0
      - script.execute: ready_timeout_watchdog

  # Watchdog to turn off ready status after timeout
  - id: ready_timeout_watchdog
    mode: restart
    then:
      - delay: ${ready_timeout_ms}ms
      - if:
          condition:
            lambda: 'return id(ready_status_shown) && !id(session_active);'
          then:
            - lambda: 'id(ready_status_shown) = false;'
            - light.turn_off: matrix_leds

  # Gentle green flash for a good read (70% brightness to protect acrylic screen)
  - id: flash_green
    mode: restart
    then:
      - light.turn_on:
          id: matrix_leds
          brightness: 70%
          red: 0.0
          green: 1.0
          blue: 0.0
      - delay: 120ms
      - light.turn_off: matrix_leds

  # Gentle red flash for blocked/duplicate
  - id: flash_red
    mode: restart
    then:
      - light.turn_on:
          id: matrix_leds
          brightness: 70%
          red: 1.0
          green: 0.0
          blue: 0.0
      - delay: 80ms
      - light.turn_off: matrix_leds

  # Retrigger the engine after an accepted read (edge OFF->ON)
  - id: rearm_after_read
    mode: restart
    then:
      - switch.turn_off: scanner_trigger
      - delay: ${rearm_success_ms}ms
      - switch.turn_on: scanner_trigger

  # Retrigger the engine after a blocked/duplicate (slightly longer pause)
  - id: rearm_after_block
    mode: restart
    then:
      - switch.turn_off: scanner_trigger
      - delay: ${rearm_block_ms}ms
      - switch.turn_on: scanner_trigger

  # Start a scan session (held scanning that auto-extends on each accepted read)
  - id: start_scan_session
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return !id(session_active);'
          then:
            - lambda: 'id(session_active) = true;'
            - lambda: 'id(ready_status_shown) = false;'  # Cancel ready status
            - switch.turn_on: scanner_aim
            - switch.turn_on: scanner_trigger
            - lambda: 'id(session_last_ms) = millis();'   # start session timer
            - script.execute: session_watchdog
          else:
            - lambda: 'id(session_last_ms) = millis();'   # refresh session timer

  # End session if no accepted scan for ${session_timeout_ms}
  - id: session_watchdog
    mode: restart
    then:
      - while:
          condition:
            lambda: |-
              const uint32_t SESSION_TIMEOUT_MS = ${session_timeout_ms};
              return (millis() - id(session_last_ms) < SESSION_TIMEOUT_MS);
          then:
            - delay: 1s
      - switch.turn_off: scanner_trigger
      - switch.turn_off: scanner_aim
      - lambda: 'id(session_active) = false;'
      - lambda: 'id(last_activity_ms) = millis();'  # Reset deep sleep timer after session ends

# ---------- UI button to start a session ----------
# Keep as a proper "button" entity; add it to a Tile/Button card in HA for one-tap use.
button:
  - platform: template
    name: "Start Scan Session"
    on_press:
      - lambda: 'id(last_activity_ms) = millis();'  # Reset deep sleep timer
      - script.stop: show_ready_status        # Stop ready status if showing
      - script.stop: ready_timeout_watchdog   # Stop ready watchdog
      - script.execute: start_scan_session
